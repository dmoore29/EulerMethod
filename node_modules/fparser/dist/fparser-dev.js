(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Formula"] = factory();
	else
		root["Formula"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/fparser.js":
/*!************************!*\
  !*** ./src/fparser.js ***!
  \************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

  /**
   * JS Formula Parser
   * -------------------
   * (c) 2012-2021 Alexander Schenkel, alex@alexi.ch
   *
   * JS Formula Parser takes a string, parses its mathmatical formula
   * and creates an evaluatable Formula object of it.
   *
   * Example input:
   *
   * var fObj = new Formula('sin(PI*x)/(2*PI)');
   * var result = fObj.evaluate({x: 2});
   * var results = fObj.evaluate([
   *     {x: 2},
   *     {x: 4},
   *     {x: 8}
   * ]);
   *
   * LICENSE:
   * -------------
   * MIT license, see LICENSE file
   */
  var MATH_CONSTANTS = {
    PI: Math.PI,
    E: Math.E,
    LN2: Math.LN2,
    LN10: Math.LN10,
    LOG2E: Math.LOG2E,
    LOG10E: Math.LOG10E,
    SQRT1_2: Math.SQRT1_2,
    SQRT2: Math.SQRT2
  };

  var Formula = /*#__PURE__*/function () {
    /**
     * Creates a new Formula instance
     *
     * Optional configuration can be set in the options object:
     *
     * - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters
     *
     * @param {String} fStr The formula string, e.g. 'sin(x)/cos(y)'
     * @param {Object} options An options object. Supported options:
     *    - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters
     * @param {Formula} parentFormula Internally used to build a Formula AST
     */
    function Formula(fStr) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Formula);

      this.formulaExpression = null;
      this.options = Object.assign({
        memoization: false
      }, options);
      this._variables = [];
      this._memory = {};
      this.setFormula(fStr);
      return this;
    }
    /**
     * Re-sets the given String and parses it to a formula expression. Can be used after initialization,
     * to re-use the Formula object.
     *
     * @param {String} formulaString The formula string to set/parse
     * @return {this} The Formula object (this)
     */


    _createClass(Formula, [{
      key: "setFormula",
      value: function setFormula(formulaString) {
        if (formulaString) {
          this.formulaExpression = null;
          this._variables = [];
          this._memory = {};
          this.formulaStr = formulaString;
          this.formulaExpression = this.parse(formulaString);
        }

        return this;
      }
      /**
       * Enable memoization: An expression is only evaluated once for the same input.
       * Further evaluations with the same input will return the in-memory stored result.
       */

    }, {
      key: "enableMemoization",
      value: function enableMemoization() {
        this.options.memoization = true;
      }
      /**
       * Disable in-memory memoization: each call to evaluate() is executed from scratch.
       */

    }, {
      key: "disableMemoization",
      value: function disableMemoization() {
        this.options.memoization = false;
        this._memory = {};
      }
      /**
       * Splits the given string by ',', makes sure the ',' is not within
       * a sub-expression
       * e.g.: str = "x,pow(3,4)" returns 2 elements: x and pow(3,4).
       */

    }, {
      key: "splitFunctionParams",
      value: function splitFunctionParams(toSplit) {
        // do not split on ',' within matching brackets.
        var pCount = 0,
            paramStr = '';
        var params = [];

        var _iterator = _createForOfIteratorHelper(toSplit.split('')),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var chr = _step.value;

            if (chr === ',' && pCount === 0) {
              // Found function param, save 'em
              params.push(paramStr);
              paramStr = '';
            } else if (chr === '(') {
              pCount++;
              paramStr += chr;
            } else if (chr === ')') {
              pCount--;
              paramStr += chr;

              if (pCount < 0) {
                throw new Error('ERROR: Too many closing parentheses!');
              }
            } else {
              paramStr += chr;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (pCount !== 0) {
          throw new Error('ERROR: Too many opening parentheses!');
        }

        if (paramStr.length > 0) {
          params.push(paramStr);
        }

        return params;
      }
      /**
       * Cleans the input string from unnecessary whitespace,
       * and replaces some known constants:
       */

    }, {
      key: "cleanupInputString",
      value: function cleanupInputString(s) {
        s = s.replace(/[\s]+/g, ''); // surround known math constants with [], to parse them as named variables [xxx]:

        Object.keys(MATH_CONSTANTS).forEach(function (c) {
          s = s.replace(new RegExp("\\b".concat(c, "\\b"), 'g'), "[".concat(c, "]"));
        });
        return s;
      }
      /**
       * Parses the given formula string by using a state machine into a single Expression object,
       * which represents an expression tree (aka AST).
       *
       * First, we split the string into 'expression': An expression can be:
       *   - a number, e.g. '3.45'
       *   - an unknown variable, e.g. 'x'
       *   - a single char operator, such as '*','+' etc...
       *   - a named variable, in [], e.g. [myvar]
       *   - a function, such as sin(x)
       *   - a parenthessed expression, containing other expressions
       *
       * We want to create an expression tree out of the string. This is done in 2 stages:
       * 1. form single expressions from the string: parse the string into known expression objects:
       *   - numbers/variables
       *   - operators
       *   - braces (with a sub-expression)
       *   - functions (with sub-expressions (aka argument expressions))
       *   This will lead to an array of expressions.
       *  As an example:
       *  "2 + 3 * (4 + 3 ^ 5) * sin(PI * x)" forms an array of the following expressions:
       *  `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]`
       * 2. From the raw expression array we form an expression tree by evaluating the expressions in the correct order:
       *    e.g.:
       *  the expression array `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]` will be transformed into the expression tree:
       *  ```
       *         root expr:  (+)
       *                     / \
       *                    2    (*)
       *                        / \
       *                     (*)  functionExpr(...)
       *                     / \
       *                    3   (bracket(..))
       * ```
       *
       * In the end, we have a single root expression node, which then can be evaluated in the evaluate() function.
       *
       * @param {String} str The formula string, e.g. '3*sin(PI/x)'
       * @returns {Expression} An expression object, representing the expression tree
       */

    }, {
      key: "parse",
      value: function parse(str) {
        // clean the input string first. spaces, math constant replacements etc.:
        str = this.cleanupInputString(str); // start recursive call to parse:

        return this._do_parse(str);
      }
      /**
       * @see parse(): this is the recursive parse function, without the clean string part.
       * @param {String} str
       * @returns {Expression} An expression object, representing the expression tree
       */

    }, {
      key: "_do_parse",
      value: function _do_parse(str) {
        var _this = this;

        var lastChar = str.length - 1,
            act = 0,
            state = 0,
            expressions = [],
            char = '',
            tmp = '',
            funcName = null,
            pCount = 0;

        while (act <= lastChar) {
          switch (state) {
            case 0:
              // None state, the beginning. Read a char and see what happens.
              char = str.charAt(act);

              if (char.match(/[0-9.]/)) {
                // found the beginning of a number, change state to "within-number"
                state = 'within-nr';
                tmp = '';
                act--;
              } else if (this.isOperator(char)) {
                // Simple operators. Note: '-' must be treaten specially,
                // it could be part of a number.
                // it MUST be part of a number if the last found expression
                // was an operator (or the beginning):
                if (char === '-') {
                  if (expressions.length === 0 || this.isOperatorExpr(expressions[expressions.length - 1])) {
                    state = 'within-nr';
                    tmp = '-';
                    break;
                  }
                } // Found a simple operator, store as expression:


                if (act === lastChar || this.isOperatorExpr(expressions[expressions.length - 1])) {
                  state = -1; // invalid to end with an operator, or have 2 operators in conjunction

                  break;
                } else {
                  expressions.push(Expression.createOperatorExpression(char));
                  state = 0;
                }
              } else if (char === '(') {
                // left parenthes found, seems to be the beginning of a new sub-expression:
                state = 'within-parentheses';
                tmp = '';
                pCount = 0;
              } else if (char === '[') {
                // left named var separator char found, seems to be the beginning of a named var:
                state = 'within-named-var';
                tmp = '';
              } else if (char.match(/[a-zA-Z]/)) {
                // multiple chars means it may be a function, else its a var which counts as own expression:
                if (act < lastChar && str.charAt(act + 1).match(/[a-zA-Z0-9_]/)) {
                  tmp = char;
                  state = 'within-func';
                } else {
                  // Single variable found:
                  // We need to check some special considerations:
                  // - If the last char was a number (e.g. 3x), we need to create a multiplication out of it (3*x)
                  if (expressions.length > 0 && expressions[expressions.length - 1] instanceof ValueExpression) {
                    expressions.push(Expression.createOperatorExpression('*'));
                  }

                  expressions.push(new VariableExpression(char));
                  this.registerVariable(char);
                  state = 0;
                  tmp = '';
                }
              }

              break;

            case 'within-nr':
              char = str.charAt(act);

              if (char.match(/[0-9.]/)) {
                //Still within number, store and continue
                tmp += char;

                if (act === lastChar) {
                  expressions.push(new ValueExpression(tmp));
                  state = 0;
                }
              } else {
                // Number finished on last round, so add as expression:
                if (tmp === '-') {
                  // just a single '-' means: a variable could follow (e.g. like in 3*-x), we convert it to -1: (3*-1x)
                  tmp = -1;
                }

                expressions.push(new ValueExpression(tmp));
                tmp = '';
                state = 0;
                act--;
              }

              break;

            case 'within-func':
              char = str.charAt(act);

              if (char.match(/[a-zA-Z0-9_]/)) {
                tmp += char;
              } else if (char === '(') {
                funcName = tmp;
                tmp = '';
                pCount = 0;
                state = 'within-func-parentheses';
              } else {
                throw new Error('Wrong character for function at position ' + act);
              }

              break;

            case 'within-named-var':
              char = str.charAt(act);

              if (char === ']') {
                // end of named var, create expression:
                expressions.push(new VariableExpression(tmp));
                this.registerVariable(tmp);
                tmp = '';
                state = 0;
              } else if (char.match(/[a-zA-Z0-9_]/)) {
                tmp += char;
              } else {
                throw new Error('Character not allowed within named variable: ' + char);
              }

              break;

            case 'within-parentheses':
            case 'within-func-parentheses':
              char = str.charAt(act);

              if (char === ')') {
                //Check if this is the matching closing parenthesis.If not, just read ahead.
                if (pCount <= 0) {
                  // Yes, we found the closing parenthesis, create new sub-expression:
                  if (state === 'within-parentheses') {
                    expressions.push(new BracketExpression(this._do_parse(tmp)));
                  } else if (state === 'within-func-parentheses') {
                    // Function found: create expressions from the inner argument
                    // string, and create a function expression with it:
                    var args = this.splitFunctionParams(tmp).map(function (a) {
                      return _this._do_parse(a);
                    });
                    expressions.push(new FunctionExpression(funcName, args, this));
                    funcName = null;
                  }

                  state = 0;
                } else {
                  pCount--;
                  tmp += char;
                }
              } else if (char === '(') {
                // begin of a new sub-parenthesis, increase counter:
                pCount++;
                tmp += char;
              } else {
                // all other things are just added to the sub-expression:
                tmp += char;
              }

              break;
          }

          act++;
        }

        if (state !== 0) {
          throw new Error('Could not parse formula: Syntax error.');
        }

        return this.buildExpressionTree(expressions);
      }
      /**
       * @see parse(): Builds an expression tree from the given expression array.
       * Builds a tree with a single root expression in the correct order of operator precedence.
       *
       * Note that the given expression objects are modified and linked.
       *
       * @param {*} expressions
       * @return {Expression} The root Expression of the built expression tree
       */

    }, {
      key: "buildExpressionTree",
      value: function buildExpressionTree(expressions) {
        if (expressions.length < 1) {
          return null;
        }

        var exprCopy = _toConsumableArray(expressions);

        var idx = 0;
        var expr = null; // Replace all Power expressions with a partial tree:

        while (idx < exprCopy.length) {
          expr = exprCopy[idx];

          if (expr instanceof PowerExpression) {
            if (idx === 0 || idx === exprCopy.length - 1) {
              throw new Error('Wrong operator position!');
            }

            expr.base = exprCopy[idx - 1];
            expr.exponent = exprCopy[idx + 1];
            exprCopy[idx - 1] = expr;
            exprCopy.splice(idx, 2);
          } else {
            idx++;
          }
        } // Replace all Mult/Div expressions with a partial tree:


        idx = 0;
        expr = null;

        while (idx < exprCopy.length) {
          expr = exprCopy[idx];

          if (expr instanceof MultDivExpression) {
            if (idx === 0 || idx === exprCopy.length - 1) {
              throw new Error('Wrong operator position!');
            }

            expr.left = exprCopy[idx - 1];
            expr.right = exprCopy[idx + 1];
            exprCopy[idx - 1] = expr;
            exprCopy.splice(idx, 2);
          } else {
            idx++;
          }
        } // Replace all Plus/Minus expressions with a partial tree:


        idx = 0;
        expr = null;

        while (idx < exprCopy.length) {
          expr = exprCopy[idx];

          if (expr instanceof PlusMinusExpression) {
            if (idx === 0 || idx === exprCopy.length - 1) {
              throw new Error('Wrong operator position!');
            }

            expr.left = exprCopy[idx - 1];
            expr.right = exprCopy[idx + 1];
            exprCopy[idx - 1] = expr;
            exprCopy.splice(idx, 2);
          } else {
            idx++;
          }
        }

        if (exprCopy.length !== 1) {
          throw new Error('Could not parse formula: incorrect syntax?');
        }

        return exprCopy[0];
      }
    }, {
      key: "isOperator",
      value: function isOperator(char) {
        return typeof char === 'string' && char.match(/[\+\-\*\/\^]/);
      }
    }, {
      key: "isOperatorExpr",
      value: function isOperatorExpr(expr) {
        return expr instanceof PlusMinusExpression || expr instanceof MultDivExpression || expr instanceof PowerExpression;
      }
    }, {
      key: "registerVariable",
      value: function registerVariable(varName) {
        if (this._variables.indexOf(varName) < 0) {
          this._variables.push(varName);
        }
      }
    }, {
      key: "getVariables",
      value: function getVariables() {
        return this._variables;
      }
      /**
       * Evaluates a Formula by delivering values for the Formula's variables.
       * E.g. if the formula is '3*x^2 + 2*x + 4', you should call `evaulate` as follows:
       *
       * evaluate({x:2}) --> Result: 20
       *
       * @param {Object|Array} valueObj An object containing values for variables and (unknown) functions,
       *   or an array of such objects: If an array is given, all objects are evaluated and the results
       *   also returned as array.
       * @return {Number|Array} The evaluated result, or an array with results
       */

    }, {
      key: "evaluate",
      value: function evaluate(valueObj) {
        var _this2 = this;

        // resolve multiple value objects recursively:
        if (valueObj instanceof Array) {
          return valueObj.map(function (v) {
            return _this2.evaluate(v);
          });
        }

        var expr = this.getExpression();

        if (!(expr instanceof Expression)) {
          throw new Error('No expression set: Did you init the object with a Formula?');
        }

        if (this.options.memoization) {
          var res = this.resultFromMemory(valueObj);

          if (res !== null) {
            return res;
          } else {
            res = expr.evaluate(_objectSpread(_objectSpread({}, MATH_CONSTANTS), valueObj));
            this.storeInMemory(valueObj, res);
            return res;
          }
        }

        return expr.evaluate(_objectSpread(_objectSpread({}, MATH_CONSTANTS), valueObj));
      }
    }, {
      key: "hashValues",
      value: function hashValues(valueObj) {
        return JSON.stringify(valueObj);
      }
    }, {
      key: "resultFromMemory",
      value: function resultFromMemory(valueObj) {
        var key = this.hashValues(valueObj);
        var res = this._memory[key];

        if (res !== undefined) {
          return res;
        } else {
          return null;
        }
      }
    }, {
      key: "storeInMemory",
      value: function storeInMemory(valueObj, value) {
        this._memory[this.hashValues(valueObj)] = value;
      }
    }, {
      key: "getExpression",
      value: function getExpression() {
        return this.formulaExpression;
      }
    }, {
      key: "getExpressionString",
      value: function getExpressionString() {
        return this.formulaExpression ? this.formulaExpression.toString() : '';
      }
    }], [{
      key: "calc",
      value: function calc(formula, valueObj) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        valueObj = valueObj || {};
        return new Formula(formula, options).evaluate(valueObj);
      }
    }]);

    return Formula;
  }();

  _exports.default = Formula;

  var Expression = /*#__PURE__*/function () {
    function Expression() {
      _classCallCheck(this, Expression);
    }

    _createClass(Expression, [{
      key: "evaluate",
      value: function evaluate() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        throw new Error('Must be defined in child classes');
      }
    }, {
      key: "toString",
      value: function toString() {
        return '';
      }
    }], [{
      key: "createOperatorExpression",
      value: function createOperatorExpression(operator) {
        var left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var right = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        if (operator === '^') {
          return new PowerExpression(operator, left, right);
        }

        if (operator === '*' || operator === '/') {
          return new MultDivExpression(operator, left, right);
        }

        if (operator === '+' || operator === '-') {
          return new PlusMinusExpression(operator, left, right);
        }

        throw new Error("Unknown operator: ".concat(operator));
      }
    }]);

    return Expression;
  }();

  var BracketExpression = /*#__PURE__*/function (_Expression) {
    _inherits(BracketExpression, _Expression);

    var _super = _createSuper(BracketExpression);

    function BracketExpression(expr) {
      var _this3;

      _classCallCheck(this, BracketExpression);

      _this3 = _super.call(this);
      _this3.innerExpression = expr;

      if (!(_this3.innerExpression instanceof Expression)) {
        throw new Error('No inner expression given for bracket expression');
      }

      return _this3;
    }

    _createClass(BracketExpression, [{
      key: "evaluate",
      value: function evaluate() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this.innerExpression.evaluate(params);
      }
    }, {
      key: "toString",
      value: function toString() {
        return "(".concat(this.innerExpression.toString(), ")");
      }
    }]);

    return BracketExpression;
  }(Expression);

  var ValueExpression = /*#__PURE__*/function (_Expression2) {
    _inherits(ValueExpression, _Expression2);

    var _super2 = _createSuper(ValueExpression);

    function ValueExpression(value) {
      var _this4;

      _classCallCheck(this, ValueExpression);

      _this4 = _super2.call(this);
      _this4.value = Number(value);

      if (isNaN(_this4.value)) {
        throw new Error('Cannot parse number: ' + value);
      }

      return _this4;
    }

    _createClass(ValueExpression, [{
      key: "evaluate",
      value: function evaluate() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this.value;
      }
    }, {
      key: "toString",
      value: function toString() {
        return String(this.value);
      }
    }]);

    return ValueExpression;
  }(Expression);

  var PlusMinusExpression = /*#__PURE__*/function (_Expression3) {
    _inherits(PlusMinusExpression, _Expression3);

    var _super3 = _createSuper(PlusMinusExpression);

    function PlusMinusExpression(operator) {
      var _this5;

      var left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var right = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      _classCallCheck(this, PlusMinusExpression);

      _this5 = _super3.call(this);

      if (!['+', '-'].includes(operator)) {
        throw new Error("Operator not allowed in Plus/Minus expression: ".concat(operator));
      }

      _this5.operator = operator;
      _this5.left = left;
      _this5.right = right;
      return _this5;
    }

    _createClass(PlusMinusExpression, [{
      key: "evaluate",
      value: function evaluate() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (this.operator === '+') {
          return this.left.evaluate(params) + this.right.evaluate(params);
        }

        if (this.operator === '-') {
          return this.left.evaluate(params) - this.right.evaluate(params);
        }

        throw new Error('Unknown operator for PlusMinus expression');
      }
    }, {
      key: "toString",
      value: function toString() {
        return "".concat(this.left.toString(), " ").concat(this.operator, " ").concat(this.right.toString());
      }
    }]);

    return PlusMinusExpression;
  }(Expression);

  var MultDivExpression = /*#__PURE__*/function (_Expression4) {
    _inherits(MultDivExpression, _Expression4);

    var _super4 = _createSuper(MultDivExpression);

    function MultDivExpression(operator) {
      var _this6;

      var left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var right = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      _classCallCheck(this, MultDivExpression);

      _this6 = _super4.call(this);

      if (!['*', '/'].includes(operator)) {
        throw new Error("Operator not allowed in Multiply/Division expression: ".concat(operator));
      }

      _this6.operator = operator;
      _this6.left = left;
      _this6.right = right;
      return _this6;
    }

    _createClass(MultDivExpression, [{
      key: "evaluate",
      value: function evaluate() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (this.operator === '*') {
          return this.left.evaluate(params) * this.right.evaluate(params);
        }

        if (this.operator === '/') {
          return this.left.evaluate(params) / this.right.evaluate(params);
        }

        throw new Error('Unknown operator for MultDiv expression');
      }
    }, {
      key: "toString",
      value: function toString() {
        return "".concat(this.left.toString(), " ").concat(this.operator, " ").concat(this.right.toString());
      }
    }]);

    return MultDivExpression;
  }(Expression);

  var PowerExpression = /*#__PURE__*/function (_Expression5) {
    _inherits(PowerExpression, _Expression5);

    var _super5 = _createSuper(PowerExpression);

    function PowerExpression() {
      var _this7;

      var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var exponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, PowerExpression);

      _this7 = _super5.call(this);
      _this7.base = base;
      _this7.exponent = exponent;
      return _this7;
    }

    _createClass(PowerExpression, [{
      key: "evaluate",
      value: function evaluate() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return Math.pow(this.base.evaluate(params), this.exponent.evaluate(params));
      }
    }, {
      key: "toString",
      value: function toString() {
        return "".concat(this.base.toString(), "^").concat(this.exponent.toString());
      }
    }]);

    return PowerExpression;
  }(Expression);

  var FunctionExpression = /*#__PURE__*/function (_Expression6) {
    _inherits(FunctionExpression, _Expression6);

    var _super6 = _createSuper(FunctionExpression);

    function FunctionExpression(fn, argumentExpressions) {
      var _this8;

      var formulaObject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      _classCallCheck(this, FunctionExpression);

      _this8 = _super6.call(this);
      _this8.fn = fn;
      _this8.argumentExpressions = argumentExpressions || [];
      _this8.formulaObject = formulaObject;
      return _this8;
    }

    _createClass(FunctionExpression, [{
      key: "evaluate",
      value: function evaluate() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        params = params || {};
        var paramValues = this.argumentExpressions.map(function (a) {
          return a.evaluate(params);
        }); // If the params object itself has a function definition with
        // the function name, call this one:

        if (params[this.fn] instanceof Function) {
          return params[this.fn].apply(this, paramValues);
        } // perhaps the Formula object has the function? so call it:
        else if (this.formulaObject && this.formulaObject[this.fn] instanceof Function) {
          return this.formulaObject[this.fn].apply(this.formulaObject, paramValues);
        } // Has the JS Math object a function as requested? Call it:
        else if (Math[this.fn] instanceof Function) {
          return Math[this.fn].apply(this, paramValues);
        } // No more options left: sorry!
        else {
          throw new Error('Function not found: ' + this.fn);
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        return "".concat(this.fn, "(").concat(this.argumentExpressions.map(function (a) {
          return a.toString();
        }).join(', '), ")");
      }
    }]);

    return FunctionExpression;
  }(Expression);

  var VariableExpression = /*#__PURE__*/function (_Expression7) {
    _inherits(VariableExpression, _Expression7);

    var _super7 = _createSuper(VariableExpression);

    function VariableExpression(varName) {
      var _this9;

      _classCallCheck(this, VariableExpression);

      _this9 = _super7.call(this);
      _this9.varName = varName || '';
      return _this9;
    }

    _createClass(VariableExpression, [{
      key: "evaluate",
      value: function evaluate() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        // params contain variable / value pairs: If this object's variable matches
        // a varname found in the params, return the value.
        // eg: params = {x: 5,y:3}, varname = x, return 5
        if (params[this.varName] !== undefined) {
          return Number(params[this.varName]);
        } else {
          throw new Error('Cannot evaluate ' + this.varName + ': No value given');
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        return "".concat(this.varName);
      }
    }]);

    return VariableExpression;
  }(Expression);

  Formula.Expression = Expression;
  Formula.BracketExpression = BracketExpression;
  Formula.PowerExpression = PowerExpression;
  Formula.MultDivExpression = MultDivExpression;
  Formula.PlusMinusExpression = PlusMinusExpression;
  Formula.ValueExpression = ValueExpression;
  Formula.VariableExpression = VariableExpression;
  Formula.FunctionExpression = FunctionExpression;
  Formula.MATH_CONSTANTS = MATH_CONSTANTS;
  module.exports = exports.default;
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/fparser.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=fparser-dev.js.map