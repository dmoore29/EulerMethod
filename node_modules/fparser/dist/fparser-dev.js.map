{"version":3,"file":"fparser-dev.js","mappings":"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","sources":["webpack://Formula/webpack/universalModuleDefinition","webpack://Formula/./src/fparser.js","webpack://Formula/webpack/bootstrap","webpack://Formula/webpack/before-startup","webpack://Formula/webpack/startup","webpack://Formula/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Formula\"] = factory();\n\telse\n\t\troot[\"Formula\"] = factory();\n})(this, function() {\nreturn ","/**\n * JS Formula Parser\n * -------------------\n * (c) 2012-2021 Alexander Schenkel, alex@alexi.ch\n *\n * JS Formula Parser takes a string, parses its mathmatical formula\n * and creates an evaluatable Formula object of it.\n *\n * Example input:\n *\n * var fObj = new Formula('sin(PI*x)/(2*PI)');\n * var result = fObj.evaluate({x: 2});\n * var results = fObj.evaluate([\n *     {x: 2},\n *     {x: 4},\n *     {x: 8}\n * ]);\n *\n * LICENSE:\n * -------------\n * MIT license, see LICENSE file\n */\nconst MATH_CONSTANTS = {\n    PI: Math.PI,\n    E: Math.E,\n    LN2: Math.LN2,\n    LN10: Math.LN10,\n    LOG2E: Math.LOG2E,\n    LOG10E: Math.LOG10E,\n    SQRT1_2: Math.SQRT1_2,\n    SQRT2: Math.SQRT2\n};\nexport default class Formula {\n    /**\n     * Creates a new Formula instance\n     *\n     * Optional configuration can be set in the options object:\n     *\n     * - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     *\n     * @param {String} fStr The formula string, e.g. 'sin(x)/cos(y)'\n     * @param {Object} options An options object. Supported options:\n     *    - memoization (bool): If true, results are stored and re-used when evaluate() is called with the same parameters\n     * @param {Formula} parentFormula Internally used to build a Formula AST\n     */\n    constructor(fStr, options = {}) {\n        this.formulaExpression = null;\n        this.options = Object.assign(\n            {\n                memoization: false\n            },\n            options\n        );\n        this._variables = [];\n        this._memory = {};\n        this.setFormula(fStr);\n        return this;\n    }\n\n    /**\n     * Re-sets the given String and parses it to a formula expression. Can be used after initialization,\n     * to re-use the Formula object.\n     *\n     * @param {String} formulaString The formula string to set/parse\n     * @return {this} The Formula object (this)\n     */\n    setFormula(formulaString) {\n        if (formulaString) {\n            this.formulaExpression = null;\n            this._variables = [];\n            this._memory = {};\n            this.formulaStr = formulaString;\n            this.formulaExpression = this.parse(formulaString);\n        }\n        return this;\n    }\n\n    /**\n     * Enable memoization: An expression is only evaluated once for the same input.\n     * Further evaluations with the same input will return the in-memory stored result.\n     */\n    enableMemoization() {\n        this.options.memoization = true;\n    }\n\n    /**\n     * Disable in-memory memoization: each call to evaluate() is executed from scratch.\n     */\n    disableMemoization() {\n        this.options.memoization = false;\n        this._memory = {};\n    }\n\n    /**\n     * Splits the given string by ',', makes sure the ',' is not within\n     * a sub-expression\n     * e.g.: str = \"x,pow(3,4)\" returns 2 elements: x and pow(3,4).\n     */\n    splitFunctionParams(toSplit) {\n        // do not split on ',' within matching brackets.\n        let pCount = 0,\n            paramStr = '';\n        const params = [];\n        for (let chr of toSplit.split('')) {\n            if (chr === ',' && pCount === 0) {\n                // Found function param, save 'em\n                params.push(paramStr);\n                paramStr = '';\n            } else if (chr === '(') {\n                pCount++;\n                paramStr += chr;\n            } else if (chr === ')') {\n                pCount--;\n                paramStr += chr;\n                if (pCount < 0) {\n                    throw new Error('ERROR: Too many closing parentheses!');\n                }\n            } else {\n                paramStr += chr;\n            }\n        }\n        if (pCount !== 0) {\n            throw new Error('ERROR: Too many opening parentheses!');\n        }\n        if (paramStr.length > 0) {\n            params.push(paramStr);\n        }\n        return params;\n    }\n\n    /**\n     * Cleans the input string from unnecessary whitespace,\n     * and replaces some known constants:\n     */\n    cleanupInputString(s) {\n        s = s.replace(/[\\s]+/g, '');\n        // surround known math constants with [], to parse them as named variables [xxx]:\n        Object.keys(MATH_CONSTANTS).forEach((c) => {\n            s = s.replace(new RegExp(`\\\\b${c}\\\\b`, 'g'), `[${c}]`);\n        });\n        return s;\n    }\n\n    /**\n     * Parses the given formula string by using a state machine into a single Expression object,\n     * which represents an expression tree (aka AST).\n     *\n     * First, we split the string into 'expression': An expression can be:\n     *   - a number, e.g. '3.45'\n     *   - an unknown variable, e.g. 'x'\n     *   - a single char operator, such as '*','+' etc...\n     *   - a named variable, in [], e.g. [myvar]\n     *   - a function, such as sin(x)\n     *   - a parenthessed expression, containing other expressions\n     *\n     * We want to create an expression tree out of the string. This is done in 2 stages:\n     * 1. form single expressions from the string: parse the string into known expression objects:\n     *   - numbers/variables\n     *   - operators\n     *   - braces (with a sub-expression)\n     *   - functions (with sub-expressions (aka argument expressions))\n     *   This will lead to an array of expressions.\n     *  As an example:\n     *  \"2 + 3 * (4 + 3 ^ 5) * sin(PI * x)\" forms an array of the following expressions:\n     *  `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]`\n     * 2. From the raw expression array we form an expression tree by evaluating the expressions in the correct order:\n     *    e.g.:\n     *  the expression array `[2, +, 3, *, bracketExpr(4,+,3,^,5), * , functionExpr(PI,*,x)]` will be transformed into the expression tree:\n     *  ```\n     *         root expr:  (+)\n     *                     / \\\n     *                    2    (*)\n     *                        / \\\n     *                     (*)  functionExpr(...)\n     *                     / \\\n     *                    3   (bracket(..))\n     * ```\n     *\n     * In the end, we have a single root expression node, which then can be evaluated in the evaluate() function.\n     *\n     * @param {String} str The formula string, e.g. '3*sin(PI/x)'\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    parse(str) {\n        // clean the input string first. spaces, math constant replacements etc.:\n        str = this.cleanupInputString(str);\n        // start recursive call to parse:\n        return this._do_parse(str);\n    }\n\n    /**\n     * @see parse(): this is the recursive parse function, without the clean string part.\n     * @param {String} str\n     * @returns {Expression} An expression object, representing the expression tree\n     */\n    _do_parse(str) {\n        let lastChar = str.length - 1,\n            act = 0,\n            state = 0,\n            expressions = [],\n            char = '',\n            tmp = '',\n            funcName = null,\n            pCount = 0;\n\n        while (act <= lastChar) {\n            switch (state) {\n                case 0:\n                    // None state, the beginning. Read a char and see what happens.\n                    char = str.charAt(act);\n                    if (char.match(/[0-9.]/)) {\n                        // found the beginning of a number, change state to \"within-number\"\n                        state = 'within-nr';\n                        tmp = '';\n                        act--;\n                    } else if (this.isOperator(char)) {\n                        // Simple operators. Note: '-' must be treaten specially,\n                        // it could be part of a number.\n                        // it MUST be part of a number if the last found expression\n                        // was an operator (or the beginning):\n                        if (char === '-') {\n                            if (expressions.length === 0 || this.isOperatorExpr(expressions[expressions.length - 1])) {\n                                state = 'within-nr';\n                                tmp = '-';\n                                break;\n                            }\n                        }\n\n                        // Found a simple operator, store as expression:\n                        if (act === lastChar || this.isOperatorExpr(expressions[expressions.length - 1])) {\n                            state = -1; // invalid to end with an operator, or have 2 operators in conjunction\n                            break;\n                        } else {\n                            expressions.push(Expression.createOperatorExpression(char));\n                            state = 0;\n                        }\n                    } else if (char === '(') {\n                        // left parenthes found, seems to be the beginning of a new sub-expression:\n                        state = 'within-parentheses';\n                        tmp = '';\n                        pCount = 0;\n                    } else if (char === '[') {\n                        // left named var separator char found, seems to be the beginning of a named var:\n                        state = 'within-named-var';\n                        tmp = '';\n                    } else if (char.match(/[a-zA-Z]/)) {\n                        // multiple chars means it may be a function, else its a var which counts as own expression:\n                        if (act < lastChar && str.charAt(act + 1).match(/[a-zA-Z0-9_]/)) {\n                            tmp = char;\n                            state = 'within-func';\n                        } else {\n                            // Single variable found:\n                            // We need to check some special considerations:\n                            // - If the last char was a number (e.g. 3x), we need to create a multiplication out of it (3*x)\n                            if (\n                                expressions.length > 0 &&\n                                expressions[expressions.length - 1] instanceof ValueExpression\n                            ) {\n                                expressions.push(Expression.createOperatorExpression('*'));\n                            }\n                            expressions.push(new VariableExpression(char));\n                            this.registerVariable(char);\n                            state = 0;\n                            tmp = '';\n                        }\n                    }\n                    break;\n                case 'within-nr':\n                    char = str.charAt(act);\n                    if (char.match(/[0-9.]/)) {\n                        //Still within number, store and continue\n                        tmp += char;\n                        if (act === lastChar) {\n                            expressions.push(new ValueExpression(tmp));\n                            state = 0;\n                        }\n                    } else {\n                        // Number finished on last round, so add as expression:\n                        if (tmp === '-') {\n                            // just a single '-' means: a variable could follow (e.g. like in 3*-x), we convert it to -1: (3*-1x)\n                            tmp = -1;\n                        }\n                        expressions.push(new ValueExpression(tmp));\n                        tmp = '';\n                        state = 0;\n                        act--;\n                    }\n                    break;\n\n                case 'within-func':\n                    char = str.charAt(act);\n                    if (char.match(/[a-zA-Z0-9_]/)) {\n                        tmp += char;\n                    } else if (char === '(') {\n                        funcName = tmp;\n                        tmp = '';\n                        pCount = 0;\n                        state = 'within-func-parentheses';\n                    } else {\n                        throw new Error('Wrong character for function at position ' + act);\n                    }\n\n                    break;\n\n                case 'within-named-var':\n                    char = str.charAt(act);\n                    if (char === ']') {\n                        // end of named var, create expression:\n                        expressions.push(new VariableExpression(tmp));\n                        this.registerVariable(tmp);\n                        tmp = '';\n                        state = 0;\n                    } else if (char.match(/[a-zA-Z0-9_]/)) {\n                        tmp += char;\n                    } else {\n                        throw new Error('Character not allowed within named variable: ' + char);\n                    }\n                    break;\n\n                case 'within-parentheses':\n                case 'within-func-parentheses':\n                    char = str.charAt(act);\n                    if (char === ')') {\n                        //Check if this is the matching closing parenthesis.If not, just read ahead.\n                        if (pCount <= 0) {\n                            // Yes, we found the closing parenthesis, create new sub-expression:\n                            if (state === 'within-parentheses') {\n                                expressions.push(new BracketExpression(this._do_parse(tmp)));\n                            } else if (state === 'within-func-parentheses') {\n                                // Function found: create expressions from the inner argument\n                                // string, and create a function expression with it:\n                                let args = this.splitFunctionParams(tmp).map((a) => this._do_parse(a));\n                                expressions.push(new FunctionExpression(funcName, args, this));\n                                funcName = null;\n                            }\n                            state = 0;\n                        } else {\n                            pCount--;\n                            tmp += char;\n                        }\n                    } else if (char === '(') {\n                        // begin of a new sub-parenthesis, increase counter:\n                        pCount++;\n                        tmp += char;\n                    } else {\n                        // all other things are just added to the sub-expression:\n                        tmp += char;\n                    }\n                    break;\n            }\n            act++;\n        }\n\n        if (state !== 0) {\n            throw new Error('Could not parse formula: Syntax error.');\n        }\n\n        return this.buildExpressionTree(expressions);\n    }\n\n    /**\n     * @see parse(): Builds an expression tree from the given expression array.\n     * Builds a tree with a single root expression in the correct order of operator precedence.\n     *\n     * Note that the given expression objects are modified and linked.\n     *\n     * @param {*} expressions\n     * @return {Expression} The root Expression of the built expression tree\n     */\n    buildExpressionTree(expressions) {\n        if (expressions.length < 1) {\n            return null;\n        }\n        const exprCopy = [...expressions];\n        let idx = 0;\n        let expr = null;\n        // Replace all Power expressions with a partial tree:\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof PowerExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.base = exprCopy[idx - 1];\n                expr.exponent = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Mult/Div expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof MultDivExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n\n        // Replace all Plus/Minus expressions with a partial tree:\n        idx = 0;\n        expr = null;\n        while (idx < exprCopy.length) {\n            expr = exprCopy[idx];\n            if (expr instanceof PlusMinusExpression) {\n                if (idx === 0 || idx === exprCopy.length - 1) {\n                    throw new Error('Wrong operator position!');\n                }\n                expr.left = exprCopy[idx - 1];\n                expr.right = exprCopy[idx + 1];\n                exprCopy[idx - 1] = expr;\n                exprCopy.splice(idx, 2);\n            } else {\n                idx++;\n            }\n        }\n        if (exprCopy.length !== 1) {\n            throw new Error('Could not parse formula: incorrect syntax?');\n        }\n        return exprCopy[0];\n    }\n\n    isOperator(char) {\n        return typeof char === 'string' && char.match(/[\\+\\-\\*\\/\\^]/);\n    }\n\n    isOperatorExpr(expr) {\n        return (\n            expr instanceof PlusMinusExpression || expr instanceof MultDivExpression || expr instanceof PowerExpression\n        );\n    }\n\n    registerVariable(varName) {\n        if (this._variables.indexOf(varName) < 0) {\n            this._variables.push(varName);\n        }\n    }\n\n    getVariables() {\n        return this._variables;\n    }\n\n    /**\n     * Evaluates a Formula by delivering values for the Formula's variables.\n     * E.g. if the formula is '3*x^2 + 2*x + 4', you should call `evaulate` as follows:\n     *\n     * evaluate({x:2}) --> Result: 20\n     *\n     * @param {Object|Array} valueObj An object containing values for variables and (unknown) functions,\n     *   or an array of such objects: If an array is given, all objects are evaluated and the results\n     *   also returned as array.\n     * @return {Number|Array} The evaluated result, or an array with results\n     */\n    evaluate(valueObj) {\n        // resolve multiple value objects recursively:\n        if (valueObj instanceof Array) {\n            return valueObj.map((v) => this.evaluate(v));\n        }\n        let expr = this.getExpression();\n        if (!(expr instanceof Expression)) {\n            throw new Error('No expression set: Did you init the object with a Formula?');\n        }\n        if (this.options.memoization) {\n            let res = this.resultFromMemory(valueObj);\n            if (res !== null) {\n                return res;\n            } else {\n                res = expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n                this.storeInMemory(valueObj, res);\n                return res;\n            }\n        }\n        return expr.evaluate({ ...MATH_CONSTANTS, ...valueObj });\n    }\n\n    hashValues(valueObj) {\n        return JSON.stringify(valueObj);\n    }\n\n    resultFromMemory(valueObj) {\n        let key = this.hashValues(valueObj);\n        let res = this._memory[key];\n        if (res !== undefined) {\n            return res;\n        } else {\n            return null;\n        }\n    }\n\n    storeInMemory(valueObj, value) {\n        this._memory[this.hashValues(valueObj)] = value;\n    }\n\n    getExpression() {\n        return this.formulaExpression;\n    }\n\n    getExpressionString() {\n        return this.formulaExpression ? this.formulaExpression.toString() : '';\n    }\n\n    static calc(formula, valueObj, options = {}) {\n        valueObj = valueObj || {};\n        return new Formula(formula, options).evaluate(valueObj);\n    }\n}\n\nclass Expression {\n    static createOperatorExpression(operator, left = null, right = null) {\n        if (operator === '^') {\n            return new PowerExpression(operator, left, right);\n        }\n        if (operator === '*' || operator === '/') {\n            return new MultDivExpression(operator, left, right);\n        }\n        if (operator === '+' || operator === '-') {\n            return new PlusMinusExpression(operator, left, right);\n        }\n        throw new Error(`Unknown operator: ${operator}`);\n    }\n\n    evaluate(params = {}) {\n        throw new Error('Must be defined in child classes');\n    }\n\n    toString() {\n        return '';\n    }\n}\n\nclass BracketExpression extends Expression {\n    constructor(expr) {\n        super();\n        this.innerExpression = expr;\n        if (!(this.innerExpression instanceof Expression)) {\n            throw new Error('No inner expression given for bracket expression');\n        }\n    }\n    evaluate(params = {}) {\n        return this.innerExpression.evaluate(params);\n    }\n    toString() {\n        return `(${this.innerExpression.toString()})`;\n    }\n}\n\nclass ValueExpression extends Expression {\n    constructor(value) {\n        super();\n        this.value = Number(value);\n        if (isNaN(this.value)) {\n            throw new Error('Cannot parse number: ' + value);\n        }\n    }\n    evaluate(params = {}) {\n        return this.value;\n    }\n    toString() {\n        return String(this.value);\n    }\n}\n\nclass PlusMinusExpression extends Expression {\n    constructor(operator, left = null, right = null) {\n        super();\n        if (!['+', '-'].includes(operator)) {\n            throw new Error(`Operator not allowed in Plus/Minus expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params = {}) {\n        if (this.operator === '+') {\n            return this.left.evaluate(params) + this.right.evaluate(params);\n        }\n        if (this.operator === '-') {\n            return this.left.evaluate(params) - this.right.evaluate(params);\n        }\n        throw new Error('Unknown operator for PlusMinus expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\nclass MultDivExpression extends Expression {\n    constructor(operator, left = null, right = null) {\n        super();\n        if (!['*', '/'].includes(operator)) {\n            throw new Error(`Operator not allowed in Multiply/Division expression: ${operator}`);\n        }\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n    }\n\n    evaluate(params = {}) {\n        if (this.operator === '*') {\n            return this.left.evaluate(params) * this.right.evaluate(params);\n        }\n        if (this.operator === '/') {\n            return this.left.evaluate(params) / this.right.evaluate(params);\n        }\n        throw new Error('Unknown operator for MultDiv expression');\n    }\n\n    toString() {\n        return `${this.left.toString()} ${this.operator} ${this.right.toString()}`;\n    }\n}\n\nclass PowerExpression extends Expression {\n    constructor(base = null, exponent = null) {\n        super();\n        this.base = base;\n        this.exponent = exponent;\n    }\n\n    evaluate(params = {}) {\n        return Math.pow(this.base.evaluate(params), this.exponent.evaluate(params));\n    }\n\n    toString() {\n        return `${this.base.toString()}^${this.exponent.toString()}`;\n    }\n}\nclass FunctionExpression extends Expression {\n    constructor(fn, argumentExpressions, formulaObject = null) {\n        super();\n        this.fn = fn;\n        this.argumentExpressions = argumentExpressions || [];\n        this.formulaObject = formulaObject;\n    }\n\n    evaluate(params = {}) {\n        params = params || {};\n        const paramValues = this.argumentExpressions.map((a) => a.evaluate(params));\n\n        // If the params object itself has a function definition with\n        // the function name, call this one:\n        if (params[this.fn] instanceof Function) {\n            return params[this.fn].apply(this, paramValues);\n        }\n        // perhaps the Formula object has the function? so call it:\n        else if (this.formulaObject && this.formulaObject[this.fn] instanceof Function) {\n            return this.formulaObject[this.fn].apply(this.formulaObject, paramValues);\n        }\n        // Has the JS Math object a function as requested? Call it:\n        else if (Math[this.fn] instanceof Function) {\n            return Math[this.fn].apply(this, paramValues);\n        }\n        // No more options left: sorry!\n        else {\n            throw new Error('Function not found: ' + this.fn);\n        }\n    }\n\n    toString() {\n        return `${this.fn}(${this.argumentExpressions.map((a) => a.toString()).join(', ')})`;\n    }\n}\n\nclass VariableExpression extends Expression {\n    constructor(varName) {\n        super();\n        this.varName = varName || '';\n    }\n\n    evaluate(params = {}) {\n        // params contain variable / value pairs: If this object's variable matches\n        // a varname found in the params, return the value.\n        // eg: params = {x: 5,y:3}, varname = x, return 5\n        if (params[this.varName] !== undefined) {\n            return Number(params[this.varName]);\n        } else {\n            throw new Error('Cannot evaluate ' + this.varName + ': No value given');\n        }\n    }\n    toString() {\n        return `${this.varName}`;\n    }\n}\n\nFormula.Expression = Expression;\nFormula.BracketExpression = BracketExpression;\nFormula.PowerExpression = PowerExpression;\nFormula.MultDivExpression = MultDivExpression;\nFormula.PlusMinusExpression = PlusMinusExpression;\nFormula.ValueExpression = ValueExpression;\nFormula.VariableExpression = VariableExpression;\nFormula.FunctionExpression = FunctionExpression;\nFormula.MATH_CONSTANTS = MATH_CONSTANTS;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/fparser.js\");\n",""],"names":["MATH_CONSTANTS","PI","Math","E","LN2","LN10","LOG2E","LOG10E","SQRT1_2","SQRT2","Formula","fStr","options","formulaExpression","Object","assign","memoization","_variables","_memory","setFormula","formulaString","formulaStr","parse","toSplit","pCount","paramStr","params","split","chr","push","Error","length","s","replace","keys","forEach","c","RegExp","str","cleanupInputString","_do_parse","lastChar","act","state","expressions","char","tmp","funcName","charAt","match","isOperator","isOperatorExpr","Expression","createOperatorExpression","ValueExpression","VariableExpression","registerVariable","BracketExpression","args","splitFunctionParams","map","a","FunctionExpression","buildExpressionTree","exprCopy","idx","expr","PowerExpression","base","exponent","splice","MultDivExpression","left","right","PlusMinusExpression","varName","indexOf","valueObj","Array","v","evaluate","getExpression","res","resultFromMemory","storeInMemory","JSON","stringify","key","hashValues","undefined","value","toString","formula","operator","innerExpression","Number","isNaN","String","includes","pow","fn","argumentExpressions","formulaObject","paramValues","Function","apply","join"],"sourceRoot":""}